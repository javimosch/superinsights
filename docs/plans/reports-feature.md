# Reports Feature Specification

## Overview
A project-level analytics feature (positioned after AI Analysis in the UI) that generates, stores, and downloads formatted reports aggregating ingested data over specified time periods.

---

## 1. Functional Requirements

### Report Generation
- **Data Types**: PageViews, Events, Errors, Performance (individual or aggregated across all types)
- **Timeframes**: 5m, 30m, 1h, 6h, 12h, 24h, 7d, 30d, 3m, 1y (reuse from AI Analysis)
- **Custom Date Range**: Optional start/end date override
- **Filters**: Reuse existing segment filters + support saved filter templates per project
- **Formats**:
  - **PDF**: Static rendition with inline CSS, static chart graphics (no interactivity)
  - **CSV**: Both aggregated stats tables AND raw flattened records
  - **JSON**: Raw flattened records
  - **HTML (future)**: Interactive charts via Chart.js / Plotly

### Report Contents (Single PDF)
1. **Header**: Project name, icon, report period, data type, generated timestamp
2. **Summary Stats Section**: Total counts, unique users/sessions, trends (text + static sparklines)
3. **Data Type Sections** (one per selected type or all):
   - PageViews: top pages, geographic distribution, session counts
   - Events: event frequency, top events, event metadata breakdowns
   - Errors: error count, top errors, browser/device/OS distributions
   - Performance: avg/p95/p99 metrics, slow transactions, resource metrics
4. **AI Insights Section** (separate, optional): Latest AI Analysis findings if available
5. **Footer**: Generated by, timestamp, SuperInsights branding

### Async Generation & Polling
- Report generation triggers async job
- User receives immediate response with `reportId` and polling URL
- Client polls `/projects/:id/reports/:reportId/status` at regular intervals
- Once ready: `status: "completed"` with download URLs
- Timeout handling: user can retry or download partially-complete report (if applicable)

### Persistent Storage
- Reports stored in **saasbackend assets** with namespace: `{orgId}_{projectId}`
- Metadata in DB: Report model (see below)
- Auto-cleanup: expire reports after 30 days (configurable)
- Allows user to re-download any historical report

### Filter Templates
- Users can save current filter + timeframe combination as a template
- Templates appear in report generation wizard for quick re-use
- Scoped to project level

---

## 2. Non-Functional Requirements

### Performance
- Sync generation: <5s for typical 30d data
- Async generation: <30s for 1y of dense data
- PDF file size: <5MB for 1y, <20MB for largest datasets
- Polling: no more than 1 request/second per user

### Security
- Access: Owner, Admin, Viewer (read-only)
- No sensitive data in reports (API keys, secrets)
- Sanitize metadata values
- Rate limit: 1 report generation per 10s per user
- Report expiration: 30 days default (purge from assets + DB)

### Reliability
- Async job failure → expose error in poll response
- Partial data → still generate (warn in report)
- Concurrent generations: queue or deduplicate
- Audit log: report generated, downloaded, deleted

### Observability
- Structured logs: report type, format, user, duration, file size
- Metrics: generation time, file size, user engagement
- Errors: capture and alert on generation failures >10% error rate

---

## 3. Data Model

### Report (MongoDB)
```javascript
{
  _id: ObjectId,
  projectId: ObjectId (ref),
  createdBy: ObjectId (ref to User),
  name: String, // e.g., "November Performance Review"
  dataType: String, // enum: "pageviews" | "events" | "errors" | "performance" | "all"
  timeframe: String, // enum: "5m" | "30m" | "1h" | ... | "1y" | "custom"
  startDate: Date,
  endDate: Date,
  filters: Object, // segment filter criteria
  format: String, // enum: "pdf" | "csv" | "json" | "html"
  includeAiInsights: Boolean,
  status: String, // enum: "pending" | "generating" | "completed" | "failed"
  statusMessage: String, // error detail if failed
  assetId: String, // reference to saasbackend asset (namespace: {orgId}_{projectId})
  assetUrl: String, // download URL from saasbackend
  fileSize: Number, // bytes
  expiresAt: Date, // default: createdAt + 30 days
  generatedAt: Date,
  downloadCount: Number,
  createdAt: Date,
  updatedAt: Date,
  deletedAt: Date // soft delete
}
```

### FilterTemplate (MongoDB, optional)
```javascript
{
  _id: ObjectId,
  projectId: ObjectId (ref),
  name: String,
  description: String,
  filters: Object,
  createdBy: ObjectId (ref to User),
  createdAt: Date,
  updatedAt: Date
}
```

---

## 4. API/Routes

### Report Generation & Retrieval
```
GET    /projects/:id/reports
       → List saved reports (paginated, filterable by status)

GET    /projects/:id/reports/new
       → Render report generation form

POST   /projects/:id/reports/generate
       → Initiate async report generation
       → Request body: { name, dataType, timeframe, startDate, endDate, filters, format, includeAiInsights }
       → Response: { reportId, status: "pending", pollingUrl }

GET    /projects/:id/reports/:reportId/status
       → Poll generation status
       → Response: { reportId, status, progress, message, downloadUrl (if ready) }

GET    /projects/:id/reports/:reportId/download
       → Stream report file from saasbackend asset

DELETE /projects/:id/reports/:reportId
       → Soft delete (remove from DB, optionally purge asset early)
```

### Filter Templates
```
GET    /projects/:id/filter-templates
       → List saved filter templates

POST   /projects/:id/filter-templates
       → Save current filter as template
       → Request body: { name, description, filters }

DELETE /projects/:id/filter-templates/:templateId
       → Delete filter template
```

### Request/Response Examples

**POST /projects/:id/reports/generate**
```json
{
  "name": "Q4 Performance Analysis",
  "dataType": "all",
  "timeframe": "30d",
  "filters": { "country": "US", "version": "2.1.0" },
  "format": "pdf",
  "includeAiInsights": true
}
```

**Response (202 Accepted)**
```json
{
  "reportId": "507f1f77bcf86cd799439011",
  "status": "pending",
  "pollingUrl": "/projects/507f1f77bcf86cd799439012/reports/507f1f77bcf86cd799439011/status"
}
```

**GET /projects/:id/reports/:reportId/status (In Progress)**
```json
{
  "reportId": "507f1f77bcf86cd799439011",
  "status": "generating",
  "progress": 65,
  "message": "Aggregating performance metrics..."
}
```

**GET /projects/:id/reports/:reportId/status (Completed)**
```json
{
  "reportId": "507f1f77bcf86cd799439011",
  "status": "completed",
  "downloadUrl": "/projects/507f1f77bcf86cd799439012/reports/507f1f77bcf86cd799439011/download",
  "fileSize": 2458624,
  "generatedAt": "2025-12-20T06:30:00Z"
}
```

**Error Response**
```json
{
  "error": "Report generation failed",
  "code": "GENERATION_ERROR",
  "details": "No data available for selected timeframe"
}
```

---

## 5. Implementation Architecture

### Directory Structure
```
controllers/
  └─ reportController.js

models/
  ├─ Report.js
  └─ FilterTemplate.js

utils/
  ├─ reportGenerator.js       (core logic: fetch, aggregate, build context)
  ├─ reportPdfRenderer.js     (HTML → PDF via pdfkit or lightweight lib)
  ├─ reportCsvExporter.js     (aggregated + raw CSV)
  ├─ reportJsonExporter.js    (raw flattened JSON)
  └─ reportCharts.js          (static sparkline/chart generators for PDF)

routes/
  └─ reports.js

views/
  ├─ analytics/reports.ejs           (list)
  ├─ analytics/report-new.ejs        (generation form)
  ├─ analytics/report-detail.ejs     (view + download)
  ├─ analytics/report-templates.ejs  (filter templates manager)
  └─ partials/report-*.ejs           (reusable components)

jobs/ (or utils/jobs/)
  └─ reportGenerationJob.js   (async worker)
```

### Key Components

#### reportGenerator.js
- Fetch data from models (PageView, Event, Error, PerformanceMetric) filtered by timeframe + segment filters
- Aggregate into stats object: counts, top-N items, distributions, trends
- Include AI Analysis results if `includeAiInsights: true`
- Return normalized context object for renderer

#### reportPdfRenderer.js
- Accept generator context + template
- Render styled HTML (inline CSS, Tailwind classes via string builder or lightweight CSS framework)
- Convert HTML → PDF (use `pdfkit` or `html-pdf` with `wkhtmltopdf` if available)
- Embed static chart images (generated via `reportCharts.js`)
- Return PDF buffer

#### reportCsvExporter.js
- Export 1: Aggregated stats table (one row per metric)
- Export 2: Raw records (one row per event/pageview/error/metric)
- Return CSV string

#### reportJsonExporter.js
- Flatten nested stats to top-level keys (e.g., `pageview_count`, `error_top_1_name`, `error_top_1_count`)
- Include raw records array if requested
- Return JSON

#### reportCharts.js
- Generate static PNG/SVG sparklines for PDF (via `chart.js-image` or Canvas)
- Simple trend lines, bar charts for top-N items
- Return image buffer or data URL

---

## 6. Async Job Handling

### Execution Flow
1. **User submits report**: POST /projects/:id/reports/generate
2. **Controller validates** + creates Report doc with `status: "pending"`
3. **Enqueue job**: Push to queue (Redis/Bull, or DB polling)
4. **Worker picks up job**:
   - Update status to `"generating"`
   - Call reportGenerator → fetch & aggregate
   - Call appropriate exporter (PDF/CSV/JSON)
   - Upload file to saasbackend assets (namespace: `{orgId}_{projectId}`)
   - Update Report: `status: "completed"`, `assetId`, `assetUrl`, `fileSize`
5. **Client polls** `/projects/:id/reports/:reportId/status`
6. **Once ready**: Return downloadUrl

### Job Timeout & Failure
- Timeout: 5min per report (adjust based on size)
- On failure: `status: "failed"`, `statusMessage: "..."`, retain in DB for debugging
- Retry: user can retry immediately

---

## 7. PDF Rendering Strategy

### Lightweight Library Choice
- **Recommended**: `html-pdf` + `wkhtmltopdf` (system dependency) OR `pdfkit` (pure Node.js)
- **pdfkit alternative**: Use simple HTML string with inline styles, no Tailwind classes (build CSS manually or use lightweight template)
- **Fallback**: Generate styled HTML, screenshot via headless browser (avoid Puppeteer; consider alternatives like `playwright` if needed)

### Template
```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <style>
      body { font-family: Arial, sans-serif; margin: 20px; }
      .header { border-bottom: 2px solid #ccc; padding-bottom: 10px; }
      .section { page-break-inside: avoid; margin-top: 20px; }
      table { width: 100%; border-collapse: collapse; }
      th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
      .stat { font-size: 24px; font-weight: bold; }
    </style>
  </head>
  <body>
    <div class="header">
      <h1><%= projectName %></h1>
      <p>Report: <%= dataType %> | Period: <%= startDate %> to <%= endDate %></p>
    </div>
    <div class="section">
      <h2>Summary</h2>
      <p class="stat"><%= totalCount %></p>
      <!-- Charts/sparklines as img tags -->
    </div>
    <!-- Data type sections -->
  </body>
</html>
```

---

## 8. UI/Navigation

### Placement
- **URL**: `/projects/:id/reports`
- **Nav Tab**: Position after "AI Analysis" in analytics subnav

### Screens
1. **Reports List** (`reports.ejs`):
   - Table: name, type, format, created, status, actions (view, re-download, delete)
   - Filters: by status, date range
   - CTA: "Generate New Report"

2. **Generate Report** (`report-new.ejs`):
   - Wizard or single form:
     - Report name (text input)
     - Data type (radio/select)
     - Timeframe (dropdown)
     - Custom date range (optional date pickers)
     - Filters (reuse segment filter UI from AI Analysis)
     - Save as filter template (checkbox + name)
     - Format (radio: PDF, CSV, JSON)
     - Include AI Insights (checkbox)
   - Submit button: "Generate Report"

3. **Report Detail** (`report-detail.ejs`):
   - Show metadata (name, type, period, filters, created by, file size)
   - Status badge (pending → generating → completed / failed)
   - If completed: download button(s) for each format
   - If failed: error message + retry button
   - Delete button

4. **Filter Templates** (`report-templates.ejs`, optional):
   - List saved templates
   - Use template in new report form
   - Delete template

---

## 9. Access Control

### Roles
- **Owner, Admin**: Full access (generate, view, delete all reports)
- **Viewer**: Read-only (view list, download, but cannot generate or delete)

### Middleware
- `ensureProjectAccess`
- `ensureProjectRole(['owner', 'admin', 'viewer'])` (adjust to allow viewer read-only)

---

## 10. Error Handling

| Scenario | Response |
|----------|----------|
| No data in range | 200 OK, report generated but with message "No data found" |
| Invalid timeframe | 400 Bad Request, `{ error: "Invalid timeframe" }` |
| Invalid filters | 400 Bad Request, `{ error: "Invalid segment filter" }` |
| Generation timeout | 504 Gateway Timeout, retry available |
| File size >100MB | 413 Payload Too Large, suggest filtering |
| Expired report | 404 Not Found (soft-deleted or asset purged) |

---

## 11. Logging & Observability

### Audit Events
- Report generated (type, format, user, timeframe, filter count)
- Report downloaded (reportId, user, format)
- Report deleted (reportId, user, reason)
- Generation failed (reportId, error details)

### Metrics
- `reports.generated.count` (counter by type, format)
- `reports.generation.duration_ms` (histogram)
- `reports.file_size_bytes` (histogram)
- `reports.download.count` (counter)

---

## 12. Dependencies to Add

```json
{
  "pdfkit": "^0.13.0",
  "html-pdf": "^3.0.0",
  "sharp": "^0.33.0",
  "bull": "^4.0.0"
}
```

- **pdfkit** or **html-pdf**: PDF rendering
- **sharp**: Image processing for sparklines/charts
- **bull**: Job queue (Redis-backed async task runner)

---

## 13. Phase 1 (MVP) Scope

- [x] Single data type selection (start with PageViews)
- [x] Predefined timeframes (7d, 30d, 1y)
- [x] Segment filter reuse (no new templates in MVP)
- [x] PDF export only (basic layout, tables, static sparklines)
- [x] Async generation with polling
- [x] Storage in saasbackend assets
- [x] List + download + delete
- [x] Owner/Admin/Viewer access

**Out of MVP:**
- CSV/JSON (Phase 2)
- All data types aggregation (Phase 2)
- Filter templates UI (Phase 2)
- AI Insights integration (Phase 2)
- Interactive HTML reports (Phase 3)
- Report scheduling/email (Phase 3+)

---

## 14. Risks & Mitigations

| Risk | Mitigation |
|------|-----------|
| Large 1y datasets cause timeout | Async job with longer timeout, data sampling, warn user |
| PDF rendering complexity | Start with simple HTML→PDF, tables only (no fancy layouts) |
| Asset storage bloat | Implement cleanup job, set expiration, monitor storage quota |
| Concurrent job contention | Use job queue with dedupe (don't allow 2 identical reports running) |
| No data case | Generate empty report with message, don't error |

---

## 15. Definition of Done

- [ ] Report model + schema
- [ ] reportController.js with all routes
- [ ] reportGenerator.js (data aggregation)
- [ ] reportPdfRenderer.js (HTML→PDF)
- [ ] Async job setup (queue, worker)
- [ ] saasbackend asset integration (upload/download)
- [ ] UI: list, generate form, detail view
- [ ] Permission checks (role-based access)
- [ ] Error handling + validation
- [ ] Logging + audit trails
- [ ] Manual test: generate PDF for 7d PageView data
- [ ] Manual test: async polling flow
- [ ] Manual test: download + expire after 30 days
- [ ] Documentation (README for Reports feature)

---

## 16. Timeline Estimate

- **Phase 1 (MVP)**: 2–3 weeks (1 dev)
  - Week 1: Models, controller, generator, basic PDF renderer
  - Week 2: Async job setup, UI, saasbackend integration
  - Week 3: Testing, polish, edge case handling

---

## 17. Codebase References & Implementation Guides

### Data Models & Collections

#### Querying Data Models
All data models follow MongoDB + Mongoose conventions. Primary models for reports:
- **PageView** (`models/PageView.js`): Fields: `projectId`, `url`, `title`, `sessionId`, `clientId`, `timestamp`, `deviceType`, `browser`, `os`, `utmSource/Medium/Campaign`
  - Index: `{ projectId: 1, timestamp: 1 }`, `{ projectId: 1, sessionId: 1 }`
  - Aggregation example: `getViewsByDay()` in `controllers/pageViewsController.js` groups by date, counts, sorts
  
- **Event** (`models/Event.js`): Fields: `projectId`, `eventName`, `properties` (Mixed), `durationMs`, `sessionId`, `clientId`, `timestamp`
  - Index: `{ projectId: 1, eventName: 1, timestamp: 1 }`, `{ projectId: 1, eventName: 1, durationMs: 1, timestamp: 1 }`
  - Pattern: Filter by `eventName`, group by properties, calculate percentiles
  
- **Error** (`models/Error.js`): Fields: `projectId`, `message`, `errorType`, `fingerprint`, `browser`, `os`, `deviceType`, `timestamp`
  - Index: `{ projectId: 1, fingerprint: 1 }`, `{ projectId: 1, timestamp: 1 }`
  - Pattern: Group by `fingerprint` or `errorType`, count occurrences, track distribution by device/browser
  
- **PerformanceMetric** (`models/PerformanceMetric.js`): Fields: `projectId`, `lcp`, `cls`, `fid`, `ttfb`, `url`, `deviceType`, `browser`, `timestamp`
  - Index: `{ projectId: 1, url: 1 }`, `{ projectId: 1, timestamp: 1 }`
  - Pattern: Calculate percentiles (p50, p75, p95, p99) for Web Vitals

#### Date Range Parsing
Utility: `controllers/pageViewsController.js` → `getDateRange(timeframe)`
- Reuse logic for all data type controllers (Events, Errors, Performance)
- Supports: '5m', '30m', '1h', '6h', '12h', '24h', '7d', '30d', '3m', '1y'
- Returns: `{ timeframe, start: Date, end: Date }`

#### Segment Filters (Metadata Matching)
Utility: `utils/segmentFilters.js`
- `parseSegmentFilters(req)` → extracts `clientId`, `userId`, `meta` object from query/body
- `buildEventMetadataMatch(filters)` → builds MongoDB match stage for Event metadata
- `buildPageViewMetadataMatch(filters)` → builds match for PageView filters (deviceType, browser, utm params)
- `buildErrorMetadataMatch(filters)` → builds match for Error filters (browser, os, deviceType)
- `buildPerformanceMetadataMatch(filters)` → builds match for Performance filters
- Pattern: All return objects ready for `{ $match: ... }` in aggregation pipelines

### Aggregation Patterns (MongoDB)
Reference implementations in `controllers/pageViewsController.js`:
```javascript
// Basic aggregation pipeline structure
PageView.aggregate([
  { $match: { projectId, timestamp: { $gte: start, $lte: end }, ...filters } },
  { $group: { _id: groupKey, count: { $sum: 1 }, avg: { $avg: '$field' } } },
  { $sort: { _id: 1 } },
  { $project: { _id: 0, label: '$_id', value: '$count' } }
])
```
- Use `$dateToString` to group by day/hour: `{ format: '%Y-%m-%d', date: '$timestamp' }`
- For percentiles: Use `$group` with `$min`, `$max`, then calculate p95/p99 in application layer
- For top-N items: Sort descending, limit, then reverse if needed

### AI Analysis Integration
Reference: `models/AiAnalysisRun.js` & `controllers/aiAnalysisController.js`
- **Model Fields**: `projectId`, `status` (running|completed|failed), `start`, `end`, `resultMarkdown`, `durationMs`, `timeframePreset`
- **Querying Latest**: `AiAnalysisRun.findOne({ projectId }).sort({ createdAt: -1 })` for most recent run
- **Reuse timeframe logic**: AI Analysis uses same timeframe enum, date range calculation
- **Markdown results**: Store analysis findings as markdown, include in reports as-is
- **Include in Reports**: If `includeAiInsights: true`, fetch latest run for project + timeframe, append findings to report context

### SaaSBackend Integration (Assets Service)

#### Asset Model & Service
Reference: `ref-saasbackend/src/models/Asset.js` & `ref-saasbackend/src/services/assets.service.js`
- **Asset Schema**: `key` (unique), `namespace`, `visibility` (public|private), `contentType`, `sizeBytes`, `status` (uploaded|deleted), `ownerUserId`, `orgId`, `tags`, `createdAt`
- **Key Format**: Generated as `{namespace}/{year}/{month}/{randomHash}.{ext}` (e.g., `67a8c2_61c9e15/2025/12/abc123def456.pdf`)
- **Namespace**: Use `{orgId}_{projectId}` pattern for multi-tenant isolation (e.g., `507f1f77bcf86cd799439010_507f1f77bcf86cd799439011`)

#### Asset Service API
- `getAssetById(id, { status = 'uploaded' })` → fetch metadata
- `getAssetByKey(key, { status = 'uploaded' })` → fetch metadata by key
- `listAssets({ namespace, tag, visibility, status, page, limit })` → paginate assets
- `getAssetBytesById(id)` → fetch metadata + file buffer
- `getAssetBytesByKey(key)` → fetch metadata + file buffer (preferred for reports)

#### Object Storage Service
Reference: `ref-saasbackend/src/services/objectStorage.service.js`
- **Backends**: 'fs' (filesystem) or 's3' (AWS S3)
- **Key Functions**:
  - `putObject({ key, body, contentType, backend })` → upload file buffer
  - `getObject({ key, backend })` → retrieve file buffer + contentType
  - `deleteObject({ key, backend })` → delete file
  - `generateKey(originalName, prefix = 'assets')` → create unique key
- **Implementation**: Automatically uses active backend (S3 if configured, else FS)

#### Upload Namespace Config
Reference: `ref-saasbackend/src/services/uploadNamespaces.service.js` (if available)
- Namespaces enforce per-org/project policies (max file size, allowed content types)
- For Reports: Use namespace `{orgId}_{projectId}` to isolate reports per project

#### SaaSBackend Initialization
Reference: `utils/saasbackend.js`
```javascript
const { getModel, services } = require('./utils/saasbackend');
const Asset = getModel('Asset'); // Access saasbackend models
const objectStorage = services.storage.objectStorage; // or require directly
```
- In production: loads npm 'saasbackend' module
- In dev: loads `../ref-saasbackend` (included in repo)

### Access Control & Middleware

#### Authentication & Project Access
Reference: `middleware/projectAccess.js` & `middleware/auth.js`
- `ensureAuthenticated` → validates user session
- `ensureProjectAccess` → confirms user has access to project (via SaaSBackend org membership)
- `ensureProjectRole(roles)` → restricts to owner|admin|viewer
  - Roles stored in project member associations (via SaaSBackend OrganizationMember model)
  - **For Reports**: Extend to allow 'viewer' role read-only access (list + download), restrict generation to owner|admin

#### Org Context
Reference: `middleware/orgContext.js`
- `requireOrgSelected` → ensures `req.currentOrg` is set (current organization context)
- Access via `req.currentOrg._id` for namespace generation

### Logging & Audit Trails

#### Audit Logger
Reference: `utils/auditLogger.js`
- `logAudit(actionCode, meta = {})` → fire-and-forget audit event creation
- **Action Codes**: `utils/actionCodes.js` defines constants (e.g., `AI_ANALYSIS_RUN_COMPLETED`)
- **For Reports**: Add new codes like:
  - `REPORT_GENERATED`
  - `REPORT_DOWNLOADED`
  - `REPORT_DELETED`
  - `REPORT_GENERATION_FAILED`
- **Usage**: `logAudit('REPORT_GENERATED', { userId, email, projectId, reportType: 'pageviews', format: 'pdf' })`

#### Event Models
Reference: `ref-saasbackend/src/models/AuditEvent.js`
- Stored automatically by `logAudit()` → accessible for compliance/debugging
- Fields: `action`, `actorUserId`, `actorEmail`, `entityType`, `entityId`, `outcome` (success|failure), `meta`, `context`

### PDF Rendering & Export

#### HTML → PDF Options
- **pdfkit**: Pure Node.js, no system dependencies, but requires manual drawing API (complex for tables)
  - Alternative: Generate HTML, then use `html-pdf` wrapper or lightweight lib
  - Example pattern: Build HTML string with inline styles, pass to renderer
  
- **html-pdf + wkhtmltopdf**: System-level tool, good CSS support, but requires OS installation
  - Environment: Check `process.env.WKHTMLTOPDF_PATH` or rely on system PATH
  
- **Sharp**: Image processing library for sparklines/charts (if needed for static PNG charts)
  - Can generate simple bar/line chart images as buffers
  - Include as `<img src="data:image/png;base64,..." />` in HTML

#### Template Strategy
Reference: `controllers/aiAnalysisController.js` → markdown rendering (use as inspiration)
- Reuse EJS templating from views for HTML generation
- Build simple HTML string with inline CSS (no Tailwind class compilation in PDF context)
- Inject aggregated stats context into template before rendering

### Response Patterns

#### JSON Responses (API)
Reference: Controllers consistently use:
```javascript
res.status(200).json({ reportId, status: 'pending', pollingUrl: '...' });
res.status(400).json({ error: 'Invalid input', code: 'INVALID_PARAMS' });
```

#### File Streams
Reference: `ref-saasbackend/src/controllers/assets.controller.js` → `download` action
```javascript
res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
res.setHeader('Content-Type', 'application/pdf');
res.send(buffer); // or res.stream(stream)
```

#### View Rendering (HTML)
Reference: `controllers/projectController.js`
```javascript
res.render('projects/index', {
  title: 'Projects - SuperInsights',
  items: [...],
  errors: [],
  values: {},
  breadcrumbs: [...]
});
```

### Environment & Configuration

#### Standard Variables
- `process.env.NODE_ENV` ('production' | 'development')
- `process.env.UPLOAD_DIR` (default: 'uploads')
- `process.env.S3_ENDPOINT`, `S3_ACCESS_KEY_ID`, `S3_SECRET_ACCESS_KEY`, `S3_BUCKET` (S3 config)
- `process.env.MULTER_FILE_SIZE_LIMIT` (default: 1GB in bytes)

#### Database
- MongoDB connection via Mongoose (already initialized in app)
- All models use standard Mongoose patterns with `timestamps: true`

### Naming & Code Conventions

#### File Organization
- **Controllers**: camelCase, ends with `Controller.js`, exports named functions (not classes)
- **Models**: PascalCase, exports single Mongoose model
- **Utils**: camelCase, exports functions/objects
- **Services**: camelCase, ends with `.service.js`, exports functions
- **Routes**: lowercase with dashes, exports Express router

#### Function Naming
- Async queries: `getXxx()`, `fetchXxx()`, `queryXxx()`
- Mutations: `createXxx()`, `updateXxx()`, `deleteXxx()`
- Formatters: `formatXxx()`, `normalizeXxx()`, `buildXxx()`
- Validators: `validateXxx()`, `isXxx()`

#### Error Handling
- Consistent error objects: `error.message` (string), `error.code` (constant), `error.details` (optional object)
- Errors thrown, not returned; caught in route handlers, sent to client via `res.status(code).json({ error, code })`

---

**Locked**: 2025-12-20T06:27:17.748Z
